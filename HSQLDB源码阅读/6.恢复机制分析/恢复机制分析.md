### HSQLDB的恢复机制分析

软件62 周展平 2016013253

------

[TOC]

### 问题思考

#### 1. 各文件在恢复机制中的作用

+ .properties文件：存储tx_timestamp属性、modified属性以及version属性。在恢复机制中用到modified属性。
+ .script文件：存储所有操作，当数据库重新打开时重新执行其中的操作来恢复数据库
+ .data文件：存储持久化的数据
+ .log文件：存储checkpoint之后的所有操作，执行checkpoint时会合并到到script中
+ .script.new文件：用于暂存.script文件
+ .backup.new文件：用于暂存.data文件



#### 2. 数据库的更改状态

共有4种状态，在HsqlDatabaseProperties类中有8个静态常量来表示状态，分别对应状态机标识以及.properties文件中的值：

```java
// db files modified
public static final int     FILES_NOT_MODIFIED = 0;
public static final int     FILES_MODIFIED     = 1;
public static final int     FILES_MODIFIED_NEW = 2;
public static final int     FILES_NEW          = 3;
private static final String MODIFIED_NO        = "no";
private static final String MODIFIED_YES       = "yes";
private static final String MODIFIED_YES_NEW   = "yes-new-files";
private static final String MODIFIED_NO_NEW    = "no-new-files";
```



#### 3. 插入或删除数据后各文件的变化

假设操作执行成功，则

+ .script文件：无变化
+ .log文件：增加了对应的SQL语句；如果处于autocommit状态，则还会有一行commit语句
+ .data文件：无变化
+ .properties文件：如果处于autocommit状态，则会将modified属性改为FILES_MODIFIED



#### 4. 执行checkpoint后各文件的变化

假设checkpoint的操作全部成功执行，则

+ .script文件：内容包括执行前的所有内容以及.log文件中的内容
+ .log文件：被清空
+ .properties文件：modified属性改为FILES_MODIFIED
+ .data文件：无变化



#### 5. cached table和memory table数据的恢复

+ memory table：恢复过程与实验指导中的步骤基本相同，在checkpoint函数中调用checkpointClose函数和checkpointReopen函数，分别负责恢复数据和启动新的checkpoint。在checkpoint中，恢复数据过程实质是将.log文件中的语句合并到.script文件中，当然中间会使用.new文件作为副本。下一次打开数据库时，执行.script所有的语句就可以在内存中恢复所有数据。
+ cached table：与memory table不同，cached table的数据存储在.data文件中。因此，在重新打开数据库的时候，会执行.log文件中的语句得到恢复后的数据，然后将数据更新到.data文件中。在恢复过程中，不会将对数据的操作语句合并到.script文件中，因为cached table的数据不是通过执行.script文件得到的，而是从.data文件中读入的。



#### 6. 并发事务与未提交事务



+ 通过实际实验，对于3种表，未提交事务都不会恢复



#### 7. 思考题：将write、checkpoint在各个阶段可能出现的问题与恢复机制对应起来



对于checkpoint函数，我们主要分析在checkpointClose函数中可能出现的问题，源码如下：

```java
/**
     * Performs checkpoint including pre and post operations. Returns to the
     * same state as before the checkpoint.
     */
boolean checkpointClose() {

    if (filesReadOnly) {
        return true;
    }

    database.logger.logInfoEvent("checkpointClose start");
    synchLog();
    database.lobManager.synch();
    database.logger.logInfoEvent("checkpointClose synched");
    deleteOldDataFiles(); 

    try {
        writeScript(false);
        database.logger.logInfoEvent("checkpointClose script done");

        if (cache != null) {
            cache.reset();
            cache.backupDataFile(true);
        }

        properties.setProperty(HsqlDatabaseProperties.hsqldb_script_format,
                               database.logger.propScriptFormat);
        properties.setDBModified(
            HsqlDatabaseProperties.FILES_MODIFIED_NEW);
    } catch (Throwable t) {

        // backup failed perhaps due to lack of disk space
        deleteNewScript();
        deleteNewBackup();
        database.logger.logSevereEvent("checkpoint failed - recovered", t);

        return false;
    }

    closeLog();
    deleteLog();
    renameNewScript();
    renameNewBackup();

    try {
        properties.setDBModified(
            HsqlDatabaseProperties.FILES_NOT_MODIFIED);
    } catch (Throwable e) {
        database.logger.logSevereEvent(
            "logger.checkpointClose properties file save failed", e);
    }

    database.logger.logInfoEvent("checkpointClose end");

    return true;
}
```

依次分析函数中各个主要操作失败是如何解决的：

（1）writeScript或backupDataFile失败：说明.script.new或.data的备份失败，之后会进入catch语句块，删除.new文件，直接退出。此时相当于没有进行数据恢复，但是.script、.log文件没有变化，下一次执行checkpoint时还可以进行数据恢复。

（2）closeLog或deleteLog失败：关闭、删除.log文件失败，不会对数据恢复造成影响

（3）renameNewScript或renameNewBackup失败：.script.new文件和.backup.new文件没有被重命名回.script和.backup文件