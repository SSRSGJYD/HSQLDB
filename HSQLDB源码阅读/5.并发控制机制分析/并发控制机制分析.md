### HSQLDB的并发控制机制分析

软件62 周展平 2016013253

------

[TOC]

### 问题思考

#### 1. 寻找当前执行语句等待的session列表的机制

在TransactionManagerCommon类的方法中，setWaitedSessionsTPL函数对于当前语句cs等待的被持有写和读的锁的session进行查找，并保存在Session类的tempSet属性中。函数如下：

```java
boolean setWaitedSessionsTPL(Session session, Statement cs) {

        session.tempSet.clear();

        if (cs == null) { //空语句没有冲突
            return true;
        }

        if (session.abortTransaction) { //abort的session无需分析
            return false;
        }

        if (cs.isCatalogLock(txModel)) {
            getTransactionSessions(session);
        }

        HsqlName[] nameList = cs.getTableNamesForWrite(); //cs涉及到的写的表

        for (int i = 0; i < nameList.length; i++) { //对于每一个表，查找对其加了锁的session
            HsqlName name = nameList[i];

            if (name.schema == SqlInvariants.SYSTEM_SCHEMA_HSQLNAME) {
                continue;
            }

            Session holder = (Session) tableWriteLocks.get(name); //最多一个session加了写锁

            if (holder != null && holder != session) {
                session.tempSet.add(holder);
            }
			//查找所有对这张表加了读锁的session
            Iterator it = tableReadLocks.get(name); 

            while (it.hasNext()) {
                holder = (Session) it.next();

                if (holder != session) {
                    session.tempSet.add(holder);
                }
            }
        }

        nameList = cs.getTableNamesForRead(); //cs涉及到的读的表

        if (txModel == TransactionManager.MVLOCKS && session.isReadOnly()) {
            if (nameList.length > 0) {
                nameList = catalogNameList;
            }
        }

        for (int i = 0; i < nameList.length; i++) {
            HsqlName name = nameList[i];

            if (name.schema == SqlInvariants.SYSTEM_SCHEMA_HSQLNAME) {
                continue;
            }

            Session holder = (Session) tableWriteLocks.get(name); //最多一个session加了写锁

            if (holder != null && holder != session) {
                session.tempSet.add(holder);
            }
        }
		//不需要寻找加了读锁的session，因为读与读不冲突
        if (session.tempSet.isEmpty()) {
            return true;
        }

        if (checkDeadlock(session, session.tempSet)) { //检查是否出现死锁
            return true;
        }

        session.tempSet.clear();

        session.abortTransaction = true; //由于锁的原因当前语句无法执行

        return false;
    }
```

对于当前语句cs涉及到的写入的表，需要查找表的被加上写和读的锁的session，其中至多有一个session加上写锁，而可能有很多session持有读锁。

对于当前语句cs涉及到的读出的表，需要查找表的被加上写的锁，而不需要查找被加上的读的锁，因为读与读之间不发生冲突。

查询被加上写锁的session，首先调用Statement类的getTableNamesForWrite方法查找所有写入的表的名字，然后在tableWriteLocks这个hash表中通过表名查找到对应的session。查询被加上读锁的session，需要在tableReadLocks这个multivalue的hash表中通过表名查找到对应的session链表，然后依次遍历得到所有session。



#### 2.当前执行语句对要访问的表上锁的机制

这里以TransactionManager2PL类为例。在beginAction函数中首先调用setWaitedSessionsTPL方法获取所有的锁冲突的session，之后如果可以执行当前语句，则进行上锁操作：

```java
/**
     * add session to the end of queue when a transaction starts
     * (depending on isolation mode)
     */
    public void beginAction(Session session, Statement cs) {

        writeLock.lock();

        try {
            if (hasExpired) {
                session.redoAction = true;

                return;
            }

            cs = updateCurrentStatement(session, cs);

            if (cs == null) {
                return;
            }

            boolean canProceed = setWaitedSessionsTPL(session, cs); //查看是否出现锁冲突

            if (canProceed) { //当前语句可以执行
                session.isPreTransaction = true;

                if (session.tempSet.isEmpty()) { //没有锁冲突
                    lockTablesTPL(session, cs); //上锁

                    // we don't set other sessions that would now be waiting for this one too
                    // next lock release will do it
                } else {
                    setWaitingSessionTPL(session); //等待其他session释放锁
                }
            }
        } finally {
            writeLock.unlock();
        }
    }
```

其中上锁操作的进行是通过lockTablesTPL函数完成的，如下：

```java
void lockTablesTPL(Session session, Statement cs) {

        if (cs == null || session.abortTransaction) {
            return;
        }

        HsqlName[] nameList = cs.getTableNamesForWrite();

        for (int i = 0; i < nameList.length; i++) {
            HsqlName name = nameList[i];

            if (name.schema == SqlInvariants.SYSTEM_SCHEMA_HSQLNAME) { //跳过数据库的系统表
                continue;
            }

            tableWriteLocks.put(name, session); //加上写锁
        }

        nameList = cs.getTableNamesForRead();

        if (txModel == TransactionManager.MVLOCKS && session.isReadOnly()) {
            if (nameList.length > 0) {
                nameList = catalogNameList;
            }
        }

        for (int i = 0; i < nameList.length; i++) {
            HsqlName name = nameList[i];

            if (name.schema == SqlInvariants.SYSTEM_SCHEMA_HSQLNAME) { //跳过数据库的系统表
                continue;
            }

            tableReadLocks.put(name, session); //加上读锁
        }
    }
```

实现的机制是，tableWriteLocks和 tableReadLocks是hash表，分别维护了写锁和读锁的从表名到session的映射关系。上锁的操作就是在hash表中通过put方法添加对应关系。

