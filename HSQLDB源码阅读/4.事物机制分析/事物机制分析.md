### HSQLDB的事物机制分析

软件62 周展平 2016013253

------

[TOC]

### 问题思考

#### 1. 关闭AutoCommit情况下在commit之前insert语句在内存中的存在形式

在StatementDML的insertSingleRow函数设置断点，执行语句：

```sql
set autocommit false
insert into account values ('00000002', 'student1', 22)
```

可以发现，插入的记录通过data数组传入该函数，用查看器查看具体信息，如下：

![](data.PNG)

因次，insert语句要插入的数据是以数组的形式存在的，每一个属性的值对应一个对象。之后，调用了Table类的insertSingleRow函数执行插入操作，首先通过PersistentStore接口的getNewCachedObject方法创建一个Row类及其子类的对象，然后通过Session类的addInsertAction方法将这次insert事物添加到rowActionList中。



#### 2.关闭AutoCommit情况下commit的执行逻辑

Session类的commit方法如下：

```java
/**
     * Commits any uncommitted transaction this Session may have open
     *
     * @throws  HsqlException
     */
    public synchronized void commit(boolean chain) {

//        tempActionHistory.add("commit " + actionTimestamp);
        if (isClosed) {
            return;
        }

        if (sessionContext.depth > 0) {
            return;
        }

        if (isTransaction) {
            if (!database.txManager.commitTransaction(this)) { //commit失败

                // tempActionHistory.add("commit aborts " + actionTimestamp);
                rollbackNoCheck(chain); //进行回滚

                throw Error.error(ErrorCode.X_40001);
            }
        }

        endTransaction(true, chain); //结束本次transaction
		
        if (database != null && !sessionUser.isSystem()
                && database.logger.needsCheckpointReset()) {
            database.checkpointRunner.start();
        }
    }
```

commit函数首先调用database.txManager.commitTransaction方法尝试进行commit，TransactionManager2PL类的commitTransaction方法如下：

```java
public boolean commitTransaction(Session session) {

        if (session.abortTransaction) { //判断是否终止了执行，如果是则直接退出
            return false;
        }

        writeLock.lock(); //获取写数据的锁

        try {
            int limit = session.rowActionList.size();

            // new actionTimestamp used for commitTimestamp
            session.actionTimestamp         = getNextGlobalChangeTimestamp();
            session.transactionEndTimestamp = session.actionTimestamp;

            endTransaction(session); 
			//依次获取rowActionList中的action进行commit
            for (int i = 0; i < limit; i++) {
                RowAction action = (RowAction) session.rowActionList.get(i);

                action.commit(session); //对每一个action分别进行commit
            }

            adjustLobUsage(session);
            persistCommit(session); //进行持久化的commit，写入文件

            session.isTransaction = false;

            endTransactionTPL(session); 
        } finally {
            writeLock.unlock(); //释放写输入的锁
        }

        session.tempSet.clear();

        return true;
    }
```

首先调用writeLock.lock方法获取锁，之后依次对rowActionList中的action调用commit方法进行commit，然后调用persistCommit方法对commit进行持久化，其中主要的函数是PersistentStore接口的commitRow方法，调用Database.Logger类的writeInsertStatement、writeDeleteStatement等方法将执行的操作写入.script和.log文件中。



#### 3. 保存点的实现

为了实现保存点，SessionContext类维护了两个属性：savepoints是HashMappedList类型的属性，通过保存点的名称进行hash，保存对应的rowActionList的大小；savepointTimestamps是LongDeque类型的属性，用于存储保存点的时间戳（actionTimestamp）。通过Session类的savepoint函数可以注册一个保存点，如下：

```java
  /**
     *  Registers a transaction SAVEPOINT. A new SAVEPOINT with the
     *  name of an existing one replaces the old SAVEPOINT.
     *
     * @param  name name of the savepoint
     * @throws  HsqlException if there is no current transaction
     */
    public synchronized void savepoint(String name) {

        int index = sessionContext.savepoints.getIndex(name); //查找名称是否已经存在

        if (index != -1) { //如果重名，则删除旧的保存点
            sessionContext.savepoints.remove(name);
            sessionContext.savepointTimestamps.remove(index);
        }
		//添加新的保存点
        sessionContext.savepoints.add(name,
                                      ValuePool.getInt(rowActionList.size()));
        sessionContext.savepointTimestamps.addLast(actionTimestamp);
    }
```
该方法会删除同名的旧保存点，并添加新的保存点。

当transaction结束之后需要删除保存点时，调用Session类的releaseSavepoint方法，如下：

```java
    /**
     * Releases a savepoint
     *
     * @param  name name of savepoint
     * @throws  HsqlException if name does not correspond to a savepoint
     */
    public synchronized void releaseSavepoint(String name) {

        // remove this and all later savepoints
        int index = sessionContext.savepoints.getIndex(name);

        if (index < 0) {
            throw Error.error(ErrorCode.X_3B001, name);
        }
		//依次删除保存点及之后的所有保存点
        while (sessionContext.savepoints.size() > index) {
            sessionContext.savepoints.remove(sessionContext.savepoints.size()
                                             - 1);
            sessionContext.savepointTimestamps.removeLast();
        }
    }
```

此方法会删除该保存点及之后的所有保存点。如果需要回滚到某一个保存点，则需要调用Session类的rollbackToSavepoint方法，进而调用TransactionManager接口的rollbackSavepoint方法执行具体的操作。



#### 4. 主键、外键完整性约束的实现

